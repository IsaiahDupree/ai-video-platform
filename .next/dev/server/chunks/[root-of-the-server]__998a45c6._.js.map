{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/isaiahdupree/Documents/Software/ai-video-platform/src/utils/hashUserData.ts"],"sourcesContent":["/**\n * User Data Hashing Utility\n *\n * Provides consistent SHA256 hashing of PII data for Meta Pixel and CAPI.\n * Works in both browser and Node.js environments.\n *\n * Meta requires all PII (Personally Identifiable Information) to be hashed\n * with SHA256 before sending via Conversions API or Advanced Matching.\n *\n * PII Fields that should be hashed:\n * - em: email address\n * - ph: phone number\n * - fn: first name\n * - ln: last name\n * - ct: city\n * - st: state\n * - zp: zip/postal code\n * - country: country code\n * - ge: gender\n * - db: date of birth (YYYYMMDD format)\n *\n * Documentation:\n * https://developers.facebook.com/docs/marketing-api/conversions-api/parameters/customer-information-parameters\n */\n\n/**\n * Hash a string value with SHA256\n * Works in both browser (SubtleCrypto) and Node.js (crypto module)\n *\n * @param value - The string value to hash\n * @returns Promise resolving to the SHA256 hash (lowercase hex)\n */\nexport async function hashValue(value: string): Promise<string> {\n  if (!value) return '';\n\n  // Normalize: lowercase and trim whitespace\n  const normalized = value.toLowerCase().trim();\n\n  // Browser environment - use SubtleCrypto\n  if (typeof window !== 'undefined' && window.crypto && window.crypto.subtle) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(normalized);\n    const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n    return hashHex;\n  }\n\n  // Node.js environment - use crypto module\n  if (typeof require !== 'undefined') {\n    try {\n      const crypto = require('crypto');\n      return crypto.createHash('sha256').update(normalized).digest('hex');\n    } catch (error) {\n      console.error('Failed to load crypto module:', error);\n      throw new Error('Hashing not available in this environment');\n    }\n  }\n\n  throw new Error('No hashing method available');\n}\n\n/**\n * Hash a phone number according to Meta's requirements\n *\n * Phone numbers should be:\n * 1. In E.164 format (e.g., +14155551234)\n * 2. Or with country code and digits only (no spaces, dashes, etc.)\n *\n * @param phone - Phone number to hash\n * @returns Promise resolving to hashed phone number\n */\nexport async function hashPhone(phone: string): Promise<string> {\n  if (!phone) return '';\n\n  // Remove all non-digit characters except leading +\n  let cleaned = phone.trim();\n  if (cleaned.startsWith('+')) {\n    cleaned = '+' + cleaned.substring(1).replace(/\\D/g, '');\n  } else {\n    cleaned = cleaned.replace(/\\D/g, '');\n  }\n\n  return hashValue(cleaned);\n}\n\n/**\n * Hash an email address according to Meta's requirements\n *\n * Email addresses should be:\n * 1. Lowercase\n * 2. Trimmed of whitespace\n * 3. No special characters in local part (keep @ and .)\n *\n * @param email - Email address to hash\n * @returns Promise resolving to hashed email\n */\nexport async function hashEmail(email: string): Promise<string> {\n  if (!email) return '';\n\n  // Validate email format\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  const cleaned = email.toLowerCase().trim();\n\n  if (!emailRegex.test(cleaned)) {\n    console.warn('Invalid email format:', email);\n    return '';\n  }\n\n  return hashValue(cleaned);\n}\n\n/**\n * Hash a date of birth according to Meta's requirements\n *\n * Date of birth should be in YYYYMMDD format (e.g., 19900115)\n * Accepts various input formats and converts to YYYYMMDD\n *\n * @param dob - Date of birth (YYYY-MM-DD, YYYYMMDD, or Date object)\n * @returns Promise resolving to hashed date of birth\n */\nexport async function hashDateOfBirth(dob: string | Date): Promise<string> {\n  if (!dob) return '';\n\n  let formatted: string;\n\n  if (dob instanceof Date) {\n    // Use UTC to avoid timezone issues\n    const year = dob.getUTCFullYear();\n    const month = String(dob.getUTCMonth() + 1).padStart(2, '0');\n    const day = String(dob.getUTCDate()).padStart(2, '0');\n    formatted = `${year}${month}${day}`;\n  } else {\n    // Remove dashes and spaces\n    formatted = dob.replace(/[-\\s]/g, '');\n\n    // Validate YYYYMMDD format\n    if (!/^\\d{8}$/.test(formatted)) {\n      console.warn('Invalid date of birth format (expected YYYYMMDD):', dob);\n      return '';\n    }\n  }\n\n  return hashValue(formatted);\n}\n\n/**\n * User data that can be hashed\n */\nexport interface UserDataToHash {\n  email?: string;\n  phone?: string;\n  firstName?: string;\n  lastName?: string;\n  city?: string;\n  state?: string;\n  zipCode?: string;\n  country?: string;\n  gender?: 'm' | 'f';\n  dateOfBirth?: string | Date;\n}\n\n/**\n * Hashed user data in Meta CAPI format\n */\nexport interface HashedUserData {\n  em?: string;    // email\n  ph?: string;    // phone\n  fn?: string;    // first name\n  ln?: string;    // last name\n  ct?: string;    // city\n  st?: string;    // state\n  zp?: string;    // zip code\n  country?: string;\n  ge?: string;    // gender\n  db?: string;    // date of birth\n}\n\n/**\n * Hash all user data fields\n *\n * Converts user-friendly field names to Meta's abbreviated format\n * and hashes all PII values with SHA256.\n *\n * @param userData - User data to hash\n * @returns Promise resolving to hashed user data in Meta CAPI format\n *\n * @example\n * const hashed = await hashUserData({\n *   email: 'user@example.com',\n *   phone: '+14155551234',\n *   firstName: 'John',\n *   lastName: 'Doe',\n * });\n * // Returns: { em: 'abc123...', ph: 'def456...', fn: 'xyz789...', ln: '...'}\n */\nexport async function hashUserData(userData: UserDataToHash): Promise<HashedUserData> {\n  const hashed: HashedUserData = {};\n\n  // Hash email\n  if (userData.email) {\n    hashed.em = await hashEmail(userData.email);\n  }\n\n  // Hash phone\n  if (userData.phone) {\n    hashed.ph = await hashPhone(userData.phone);\n  }\n\n  // Hash first name\n  if (userData.firstName) {\n    hashed.fn = await hashValue(userData.firstName);\n  }\n\n  // Hash last name\n  if (userData.lastName) {\n    hashed.ln = await hashValue(userData.lastName);\n  }\n\n  // Hash city\n  if (userData.city) {\n    hashed.ct = await hashValue(userData.city);\n  }\n\n  // Hash state\n  if (userData.state) {\n    hashed.st = await hashValue(userData.state);\n  }\n\n  // Hash zip code\n  if (userData.zipCode) {\n    hashed.zp = await hashValue(userData.zipCode);\n  }\n\n  // Hash country (should be 2-letter ISO country code)\n  if (userData.country) {\n    hashed.country = await hashValue(userData.country);\n  }\n\n  // Hash gender (should be 'm' or 'f')\n  if (userData.gender) {\n    hashed.ge = await hashValue(userData.gender);\n  }\n\n  // Hash date of birth\n  if (userData.dateOfBirth) {\n    hashed.db = await hashDateOfBirth(userData.dateOfBirth);\n  }\n\n  return hashed;\n}\n\n/**\n * Validate that a string is a valid SHA256 hash\n *\n * @param hash - String to validate\n * @returns True if valid SHA256 hash (64 hex characters)\n */\nexport function isValidSHA256Hash(hash: string): boolean {\n  return /^[a-f0-9]{64}$/i.test(hash);\n}\n\n/**\n * Check if user data is already hashed\n *\n * Useful to avoid double-hashing data that's already been hashed\n *\n * @param userData - User data to check\n * @returns True if all present fields appear to be SHA256 hashes\n */\nexport function isUserDataHashed(userData: HashedUserData): boolean {\n  const values = Object.values(userData).filter(v => typeof v === 'string' && v.length > 0);\n\n  if (values.length === 0) return false;\n\n  return values.every(value => isValidSHA256Hash(value as string));\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":["file:///Users/isaiahdupree/Documents/Software/ai-video-platform/src/app/api/meta/hash-user-data/route.ts"],"sourcesContent":["/**\n * API Endpoint: Hash User Data\n *\n * POST /api/meta/hash-user-data\n *\n * Hashes user PII data with SHA256 for Meta Pixel/CAPI tracking.\n * This endpoint allows the client to hash sensitive user data server-side\n * before sending to Meta for conversion tracking.\n *\n * Security Notes:\n * - This endpoint should be rate-limited in production\n * - Consider adding authentication if needed\n * - User data is not stored, only hashed and returned\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { hashUserData, UserDataToHash } from '@/utils/hashUserData';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const userData: UserDataToHash = await request.json();\n\n    // Validate that we have at least one field to hash\n    if (!userData || Object.keys(userData).length === 0) {\n      return NextResponse.json(\n        { error: 'No user data provided' },\n        { status: 400 }\n      );\n    }\n\n    // Hash all provided user data\n    const hashedData = await hashUserData(userData);\n\n    return NextResponse.json({\n      success: true,\n      hashedData,\n    });\n  } catch (error) {\n    console.error('[Hash User Data API] Error:', error);\n\n    return NextResponse.json(\n      {\n        error: 'Failed to hash user data',\n        message: error instanceof Error ? error.message : 'Unknown error',\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;CAaC,GAED;AACA;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,WAA2B,MAAM,QAAQ,IAAI;QAEnD,mDAAmD;QACnD,IAAI,CAAC,YAAY,OAAO,IAAI,CAAC,UAAU,MAAM,KAAK,GAAG;YACnD,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAElB;QAEA,8BAA8B;QAC9B,MAAM,aAAa,MAAM,IAAA,8IAAY,EAAC;QAEtC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAE7C,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QACpD,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}