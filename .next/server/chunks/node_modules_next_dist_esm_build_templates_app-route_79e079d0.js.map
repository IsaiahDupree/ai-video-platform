{"version":3,"sources":["../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../src/app/api/webhooks/stripe/route.ts","../../../src/utils/stripeWebhookVerify.ts","../../../src/services/subscriptionSnapshot.ts","../../../src/types/stripeWebhook.ts","../../../src/services/stripeWebhookProcessor.ts"],"sourcesContent":["import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/webhooks/stripe/route\",\n        pathname: \"/api/webhooks/stripe\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/webhooks/stripe/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/webhooks/stripe/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        const silenceLog = false;\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, silenceLog, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","/**\n * Stripe Webhook Handler\n * API route for handling Stripe webhook events (GDP-007)\n *\n * This endpoint receives webhook events from Stripe for:\n * - customer.subscription.created\n * - customer.subscription.updated\n * - customer.subscription.deleted\n * - customer.subscription.trial_will_end\n * - invoice.payment_succeeded\n * - invoice.payment_failed\n * - charge.succeeded\n * - charge.failed\n * - charge.refunded\n * - payment_intent.succeeded\n * - payment_intent.payment_failed\n *\n * Events are verified, parsed, and stored in the Growth Data Plane.\n * Subscriptions are created/updated to track active subscriptions.\n *\n * Setup:\n * 1. Add STRIPE_WEBHOOK_SECRET to .env (get from Stripe dashboard)\n * 2. Configure webhook in Stripe: https://dashboard.stripe.com/webhooks\n * 3. Set webhook URL: https://your-domain.com/api/webhooks/stripe\n * 4. Enable events: subscription, invoice, charge, payment_intent\n *\n * @see https://stripe.com/docs/webhooks\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { verifyStripeWebhook } from '@/utils/stripeWebhookVerify';\nimport { processStripeWebhook } from '@/services/stripeWebhookProcessor';\nimport { StripeWebhookEvent } from '@/types/stripeWebhook';\n\n/**\n * POST /api/webhooks/stripe\n * Handle Stripe webhook events\n */\nexport async function POST(request: NextRequest) {\n  try {\n    // Get webhook secret from environment\n    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;\n\n    if (!webhookSecret) {\n      console.error('STRIPE_WEBHOOK_SECRET is not configured');\n      return NextResponse.json(\n        { error: 'Webhook secret not configured' },\n        { status: 500 }\n      );\n    }\n\n    // Get raw body for signature verification\n    const rawBody = await request.text();\n\n    // Get Stripe signature header\n    const signature = request.headers.get('stripe-signature');\n\n    if (!signature) {\n      console.warn('Missing Stripe-Signature header in webhook request');\n      return NextResponse.json(\n        { error: 'Missing webhook signature' },\n        { status: 400 }\n      );\n    }\n\n    // Verify webhook signature\n    const isValid = verifyStripeWebhook(rawBody, signature, webhookSecret);\n\n    if (!isValid) {\n      console.warn('Invalid Stripe webhook signature');\n      return NextResponse.json(\n        { error: 'Invalid webhook signature' },\n        { status: 401 }\n      );\n    }\n\n    // Parse webhook payload\n    let payload: StripeWebhookEvent;\n    try {\n      payload = JSON.parse(rawBody);\n    } catch (error) {\n      console.error('Failed to parse webhook payload:', error);\n      return NextResponse.json(\n        { error: 'Invalid JSON payload' },\n        { status: 400 }\n      );\n    }\n\n    // Log webhook event\n    console.log(`Received Stripe webhook: ${payload.type}`, {\n      event_id: payload.id,\n      created: new Date(payload.created * 1000).toISOString(),\n      livemode: payload.livemode,\n    });\n\n    // Process webhook and store in Growth Data Plane\n    const result = await processStripeWebhook(payload);\n\n    if (result.eventId) {\n      return NextResponse.json({\n        success: true,\n        event_id: result.eventId,\n        subscription_id: result.subscriptionId,\n        message: 'Webhook processed successfully',\n      });\n    } else {\n      // Event was skipped (e.g., we don't track this event type)\n      return NextResponse.json({\n        success: true,\n        message: 'Webhook received but not processed',\n      });\n    }\n  } catch (error) {\n    console.error('Error handling Stripe webhook:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * GET /api/webhooks/stripe\n * Health check endpoint\n */\nexport async function GET() {\n  return NextResponse.json({\n    status: 'ok',\n    message: 'Stripe webhook endpoint is active',\n    configured: !!process.env.STRIPE_WEBHOOK_SECRET,\n  });\n}\n","/**\n * Stripe Webhook Verification Utility\n * Verifies Stripe webhook signatures using HMAC SHA256\n *\n * @see https://stripe.com/docs/webhooks/signatures\n */\n\nimport crypto from 'crypto';\n\n/**\n * Verify Stripe webhook signature\n *\n * Stripe signs each webhook with a secret. We need to verify the signature\n * to ensure the webhook came from Stripe and hasn't been tampered with.\n *\n * @param payload - Raw webhook payload (as string/buffer)\n * @param signature - Stripe-Signature header value\n * @param secret - Webhook signing secret from Stripe dashboard\n * @param tolerance - Time tolerance in seconds (default: 300 = 5 minutes)\n * @returns true if signature is valid, false otherwise\n */\nexport function verifyStripeWebhook(\n  payload: string | Buffer,\n  signature: string,\n  secret: string,\n  tolerance: number = 300\n): boolean {\n  try {\n    // Stripe-Signature format: t=<timestamp>,v1=<signature>[,v1=<signature>...]\n    const signedContent = signature.split(',');\n\n    let timestamp: string | null = null;\n    let signatures: string[] = [];\n\n    for (const item of signedContent) {\n      const [key, value] = item.split('=', 2);\n      if (key === 't') {\n        timestamp = value;\n      } else if (key === 'v1') {\n        signatures.push(value);\n      }\n    }\n\n    if (!timestamp || signatures.length === 0) {\n      console.warn('Invalid Stripe-Signature format');\n      return false;\n    }\n\n    // Check timestamp is within tolerance\n    const now = Math.floor(Date.now() / 1000);\n    const ts = parseInt(timestamp, 10);\n\n    if (isNaN(ts) || Math.abs(now - ts) > tolerance) {\n      console.warn(\n        `Webhook timestamp outside tolerance window. Now: ${now}, ts: ${ts}, diff: ${Math.abs(now - ts)}s`\n      );\n      return false;\n    }\n\n    // Reconstruct the signed content\n    const payloadStr = typeof payload === 'string' ? payload : payload.toString('utf-8');\n    const signedString = `${timestamp}.${payloadStr}`;\n\n    // Compute the expected signature\n    const expectedSignature = crypto\n      .createHmac('sha256', secret)\n      .update(signedString)\n      .digest('hex');\n\n    // Check if any signature matches (use timing-safe comparison)\n    for (const sig of signatures) {\n      try {\n        if (crypto.timingSafeEqual(Buffer.from(sig), Buffer.from(expectedSignature))) {\n          return true;\n        }\n      } catch {\n        // timingSafeEqual throws if lengths don't match\n        continue;\n      }\n    }\n\n    console.warn('Stripe webhook signature mismatch');\n    return false;\n  } catch (error) {\n    console.error('Error verifying Stripe webhook signature:', error);\n    return false;\n  }\n}\n\n/**\n * Parse Stripe-Signature header to get timestamp\n * Useful for logging/debugging\n *\n * @param signature - Stripe-Signature header value\n * @returns parsed signature data or null if invalid\n */\nexport function parseStripeSignature(signature: string): {\n  timestamp: number;\n  signatures: string[];\n} | null {\n  try {\n    const signedContent = signature.split(',');\n    let timestamp: string | null = null;\n    let signatures: string[] = [];\n\n    for (const item of signedContent) {\n      const [key, value] = item.split('=', 2);\n      if (key === 't') {\n        timestamp = value;\n      } else if (key === 'v1') {\n        signatures.push(value);\n      }\n    }\n\n    if (!timestamp || signatures.length === 0) {\n      return null;\n    }\n\n    return {\n      timestamp: parseInt(timestamp, 10),\n      signatures,\n    };\n  } catch (error) {\n    console.error('Error parsing Stripe signature:', error);\n    return null;\n  }\n}\n\n/**\n * Validate webhook timestamp is recent\n * Stripe recommends checking timestamp is within 5 minutes\n *\n * @param timestamp - Unix timestamp from webhook\n * @param tolerance - Time tolerance in seconds (default: 300)\n * @returns true if timestamp is recent, false otherwise\n */\nexport function validateWebhookTimestamp(\n  timestamp: number | string,\n  tolerance: number = 300\n): boolean {\n  try {\n    const ts = typeof timestamp === 'string' ? parseInt(timestamp, 10) : timestamp;\n    if (isNaN(ts)) {\n      return false;\n    }\n\n    const now = Math.floor(Date.now() / 1000);\n    return Math.abs(now - ts) <= tolerance;\n  } catch (error) {\n    console.error('Error validating webhook timestamp:', error);\n    return false;\n  }\n}\n","/**\n * GDP-008: Subscription Snapshot Service\n *\n * Tracks point-in-time snapshots of subscription state for churn and expansion tracking.\n * - Creates snapshots daily/monthly\n * - Calculates MRR changes and churn status\n * - Tracks expansion vs contraction vs churn\n */\n\nimport { createClient } from '@supabase/supabase-js';\nimport type {\n  SubscriptionSnapshot,\n  SubscriptionSnapshotInput,\n  Subscription,\n} from '@/types/growthDataPlane';\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL || '',\n  process.env.SUPABASE_SERVICE_ROLE_KEY || ''\n);\n\n/**\n * Create a subscription snapshot\n */\nexport async function createSubscriptionSnapshot(\n  input: SubscriptionSnapshotInput\n): Promise<SubscriptionSnapshot> {\n  // Mark existing snapshots as non-current\n  await supabase\n    .from('subscription_snapshots')\n    .update({ is_current: false })\n    .eq('subscription_id', input.subscription_id)\n    .eq('is_current', true);\n\n  // Insert new snapshot\n  const { data, error } = await supabase\n    .from('subscription_snapshots')\n    .insert({\n      subscription_id: input.subscription_id,\n      person_id: input.person_id,\n      status: input.status,\n      mrr_cents: input.mrr_cents,\n      amount_cents: input.amount_cents,\n      currency: input.currency,\n      current_period_start: input.current_period_start,\n      current_period_end: input.current_period_end,\n      canceled_at: input.canceled_at,\n      ended_at: input.ended_at,\n      mrr_change_cents: input.mrr_change_cents,\n      churn_status: input.churn_status || 'active',\n      churn_reason: input.churn_reason,\n      snapshot_date: new Date().toISOString().split('T')[0],\n      snapshot_period: 'daily',\n      is_current: true,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    throw new Error(`Failed to create subscription snapshot: ${error.message}`);\n  }\n\n  return data as SubscriptionSnapshot;\n}\n\n/**\n * Get latest snapshot for a subscription\n */\nexport async function getLatestSubscriptionSnapshot(\n  subscriptionId: string\n): Promise<SubscriptionSnapshot | null> {\n  const { data, error } = await supabase\n    .from('subscription_snapshots')\n    .select('*')\n    .eq('subscription_id', subscriptionId)\n    .eq('is_current', true)\n    .single();\n\n  if (error && error.code === 'PGRST116') {\n    // No rows found\n    return null;\n  }\n\n  if (error) {\n    throw new Error(\n      `Failed to get latest subscription snapshot: ${error.message}`\n    );\n  }\n\n  return data as SubscriptionSnapshot;\n}\n\n/**\n * Get all snapshots for a subscription\n */\nexport async function getSubscriptionSnapshots(\n  subscriptionId: string,\n  limit: number = 30\n): Promise<SubscriptionSnapshot[]> {\n  const { data, error } = await supabase\n    .from('subscription_snapshots')\n    .select('*')\n    .eq('subscription_id', subscriptionId)\n    .order('snapshot_date', { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    throw new Error(\n      `Failed to get subscription snapshots: ${error.message}`\n    );\n  }\n\n  return (data || []) as SubscriptionSnapshot[];\n}\n\n/**\n * Get all snapshots for a person\n */\nexport async function getPersonSubscriptionSnapshots(\n  personId: string,\n  limit: number = 30\n): Promise<SubscriptionSnapshot[]> {\n  const { data, error } = await supabase\n    .from('subscription_snapshots')\n    .select('*')\n    .eq('person_id', personId)\n    .order('snapshot_date', { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    throw new Error(\n      `Failed to get person subscription snapshots: ${error.message}`\n    );\n  }\n\n  return (data || []) as SubscriptionSnapshot[];\n}\n\n/**\n * Calculate MRR change from subscription update\n */\nexport function calculateMrrChange(\n  oldSubscription: Subscription | null,\n  newSubscription: Subscription\n): number {\n  if (!oldSubscription) {\n    return newSubscription.mrr_cents || 0;\n  }\n\n  const oldMrr = oldSubscription.mrr_cents || 0;\n  const newMrr = newSubscription.mrr_cents || 0;\n\n  return newMrr - oldMrr;\n}\n\n/**\n * Calculate churn status from subscription changes\n */\nexport function calculateChurnStatus(\n  oldSubscription: Subscription | null,\n  newSubscription: Subscription\n): 'active' | 'churned' | 'reactivated' {\n  if (!oldSubscription) {\n    return 'active';\n  }\n\n  // Churned: transitioned to canceled/past_due/unpaid\n  if (\n    oldSubscription.status === 'active' &&\n    ['canceled', 'past_due', 'unpaid'].includes(newSubscription.status)\n  ) {\n    return 'churned';\n  }\n\n  // Reactivated: moved back to active from inactive status\n  if (\n    ['canceled', 'past_due', 'unpaid'].includes(oldSubscription.status) &&\n    newSubscription.status === 'active'\n  ) {\n    return 'reactivated';\n  }\n\n  return 'active';\n}\n\n/**\n * Create snapshot when subscription is updated\n */\nexport async function createSnapshotFromSubscription(\n  subscription: Subscription,\n  previousSnapshot?: SubscriptionSnapshot\n): Promise<SubscriptionSnapshot> {\n  // Calculate MRR change\n  const mrrChange = previousSnapshot\n    ? subscription.mrr_cents! - previousSnapshot.mrr_cents\n    : subscription.mrr_cents || 0;\n\n  // Determine churn status\n  const previousStatus = previousSnapshot?.status;\n  let churnStatus: 'active' | 'churned' | 'reactivated' = 'active';\n  let churnReason: string | undefined;\n\n  if (previousStatus && previousStatus !== subscription.status) {\n    if (\n      previousStatus === 'active' &&\n      ['canceled', 'past_due', 'unpaid'].includes(subscription.status)\n    ) {\n      churnStatus = 'churned';\n      churnReason =\n        subscription.status === 'canceled'\n          ? 'Subscription canceled'\n          : `Subscription status: ${subscription.status}`;\n    } else if (\n      ['canceled', 'past_due', 'unpaid'].includes(previousStatus) &&\n      subscription.status === 'active'\n    ) {\n      churnStatus = 'reactivated';\n      churnReason = 'Subscription reactivated';\n    }\n  }\n\n  return createSubscriptionSnapshot({\n    subscription_id: subscription.id,\n    person_id: subscription.person_id,\n    status: subscription.status,\n    mrr_cents: subscription.mrr_cents || 0,\n    amount_cents: subscription.amount_cents,\n    currency: subscription.currency,\n    current_period_start: subscription.current_period_start,\n    current_period_end: subscription.current_period_end,\n    canceled_at: subscription.canceled_at,\n    ended_at: subscription.ended_at,\n    mrr_change_cents: mrrChange,\n    churn_status: churnStatus,\n    churn_reason: churnReason,\n  });\n}\n\n/**\n * Get cohort metrics for subscription snapshots\n * Returns aggregated metrics for subscriptions at a point in time\n */\nexport async function getSubscriptionCohortMetrics(\n  personIds: string[],\n  snapshotDate: string\n): Promise<{\n  total_subscriptions: number;\n  active_subscriptions: number;\n  total_mrr_cents: number;\n  churned_count: number;\n  reactivated_count: number;\n}> {\n  const { data, error } = await supabase\n    .from('subscription_snapshots')\n    .select(\n      'status, mrr_cents, churn_status',\n      { count: 'exact' }\n    )\n    .in('person_id', personIds)\n    .eq('snapshot_date', snapshotDate);\n\n  if (error) {\n    throw new Error(`Failed to get cohort metrics: ${error.message}`);\n  }\n\n  const snapshots = (data || []) as any[];\n\n  return {\n    total_subscriptions: snapshots.length,\n    active_subscriptions: snapshots.filter(\n      (s) => s.status === 'active'\n    ).length,\n    total_mrr_cents: snapshots.reduce((sum, s) => sum + (s.mrr_cents || 0), 0),\n    churned_count: snapshots.filter((s) => s.churn_status === 'churned').length,\n    reactivated_count: snapshots.filter(\n      (s) => s.churn_status === 'reactivated'\n    ).length,\n  };\n}\n\n/**\n * Get MRR trend over time\n */\nexport async function getMrrTrend(\n  subscriptionId: string,\n  days: number = 90\n): Promise<Array<{ date: string; mrr_cents: number }>> {\n  const startDate = new Date();\n  startDate.setDate(startDate.getDate() - days);\n\n  const { data, error } = await supabase\n    .from('subscription_snapshots')\n    .select('snapshot_date, mrr_cents')\n    .eq('subscription_id', subscriptionId)\n    .gte('snapshot_date', startDate.toISOString().split('T')[0])\n    .order('snapshot_date', { ascending: true });\n\n  if (error) {\n    throw new Error(`Failed to get MRR trend: ${error.message}`);\n  }\n\n  return (data || []).map((row: any) => ({\n    date: row.snapshot_date,\n    mrr_cents: row.mrr_cents,\n  }));\n}\n\n/**\n * Get churn summary for a person\n */\nexport async function getPersonChurnSummary(\n  personId: string\n): Promise<{\n  total_churned: number;\n  total_reactivated: number;\n  current_subscriptions: number;\n  active_subscriptions: number;\n  total_mrr_cents: number;\n}> {\n  const { data, error } = await supabase\n    .from('subscription_snapshots')\n    .select('status, churn_status, mrr_cents, is_current');\n\n  if (error) {\n    throw new Error(`Failed to get churn summary: ${error.message}`);\n  }\n\n  const snapshots = (data || []).filter((s: any) => s.person_id === personId);\n\n  const currentSnapshots = snapshots.filter((s: any) => s.is_current);\n\n  return {\n    total_churned: snapshots.filter((s: any) => s.churn_status === 'churned')\n      .length,\n    total_reactivated: snapshots.filter((s: any) => s.churn_status === 'reactivated')\n      .length,\n    current_subscriptions: currentSnapshots.length,\n    active_subscriptions: currentSnapshots.filter((s: any) => s.status === 'active')\n      .length,\n    total_mrr_cents: currentSnapshots.reduce(\n      (sum: number, s: any) => sum + (s.mrr_cents || 0),\n      0\n    ),\n  };\n}\n","/**\n * Stripe Webhook Types\n * TypeScript types for Stripe webhook events\n * Used by GDP-007: Stripe Webhook Integration\n */\n\n/**\n * Stripe webhook event types we handle\n */\nexport enum StripeWebhookEventType {\n  // Customer events\n  CUSTOMER_CREATED = 'customer.created',\n  CUSTOMER_UPDATED = 'customer.updated',\n  CUSTOMER_DELETED = 'customer.deleted',\n\n  // Subscription events\n  CUSTOMER_SUBSCRIPTION_CREATED = 'customer.subscription.created',\n  CUSTOMER_SUBSCRIPTION_UPDATED = 'customer.subscription.updated',\n  CUSTOMER_SUBSCRIPTION_DELETED = 'customer.subscription.deleted',\n  CUSTOMER_SUBSCRIPTION_TRIAL_WILL_END = 'customer.subscription.trial_will_end',\n\n  // Invoice events\n  INVOICE_CREATED = 'invoice.created',\n  INVOICE_FINALIZED = 'invoice.finalized',\n  INVOICE_PAYMENT_SUCCEEDED = 'invoice.payment_succeeded',\n  INVOICE_PAYMENT_FAILED = 'invoice.payment_failed',\n  INVOICE_PAYMENT_ACTION_REQUIRED = 'invoice.payment_action_required',\n  INVOICE_UPCOMING = 'invoice.upcoming',\n\n  // Charge events\n  CHARGE_SUCCEEDED = 'charge.succeeded',\n  CHARGE_FAILED = 'charge.failed',\n  CHARGE_REFUNDED = 'charge.refunded',\n  CHARGE_DISPUTE_CREATED = 'charge.dispute.created',\n\n  // Payment intent events\n  PAYMENT_INTENT_SUCCEEDED = 'payment_intent.succeeded',\n  PAYMENT_INTENT_PAYMENT_FAILED = 'payment_intent.payment_failed',\n}\n\n/**\n * Stripe subscription status\n */\nexport type StripeSubscriptionStatus =\n  | 'trialing'\n  | 'active'\n  | 'past_due'\n  | 'canceled'\n  | 'unpaid'\n  | 'incomplete'\n  | 'incomplete_expired';\n\n/**\n * Stripe webhook event structure\n */\nexport interface StripeWebhookEvent {\n  id: string;\n  object: 'event';\n  api_version: string;\n  created: number;\n  data: {\n    object: Record<string, any>;\n    previous_attributes?: Record<string, any>;\n  };\n  livemode: boolean;\n  pending_webhooks: number;\n  request: {\n    id: string | null;\n    idempotency_key: string | null;\n  };\n  type: string;\n}\n\n/**\n * Stripe customer object\n */\nexport interface StripeCustomer {\n  id: string;\n  object: 'customer';\n  address: string | null;\n  balance: number;\n  created: number;\n  currency: string | null;\n  default_source: string | null;\n  delinquent: boolean;\n  description: string | null;\n  discount: string | null;\n  email: string | null;\n  invoice_prefix: string;\n  invoice_settings?: {\n    custom_fields: Array<{ name: string; value: string }> | null;\n    default_payment_method: string | null;\n    footer: string | null;\n  };\n  livemode: boolean;\n  metadata: Record<string, any>;\n  name: string | null;\n  phone: string | null;\n  preferred_locales: string[];\n  shipping: string | null;\n  tax_exempt: 'none' | 'exempt' | 'reverse';\n  test_clock: string | null;\n}\n\n/**\n * Stripe subscription object\n */\nexport interface StripeSubscription {\n  id: string;\n  object: 'subscription';\n  application: string | null;\n  application_fee_percent: number | null;\n  automatic_tax: {\n    enabled: boolean;\n  };\n  billing_cycle_anchor: number;\n  billing_thresholds: {\n    amount_gte: number | null;\n    reset_billing_cycle_anchor: boolean;\n  } | null;\n  cancel_at: number | null;\n  cancel_at_period_end: boolean;\n  canceled_at: number | null;\n  collection_method: 'charge_automatically' | 'send_invoice';\n  created: number;\n  currency: string;\n  current_period_end: number;\n  current_period_start: number;\n  customer: string;\n  days_until_due: number | null;\n  default_payment_method: string | null;\n  default_source: string | null;\n  default_tax_rates: string[];\n  description: string | null;\n  discount: string | null;\n  ended_at: number | null;\n  items: {\n    object: 'list';\n    data: Array<{\n      id: string;\n      billing_thresholds: Record<string, any> | null;\n      created: number;\n      currency: string;\n      custom_price_data?: Record<string, any>;\n      metadata: Record<string, any>;\n      price: {\n        id: string;\n        object: 'price';\n        active: boolean;\n        billing_scheme: 'per_unit' | 'tiered';\n        created: number;\n        currency: string;\n        custom_unit_amount: Record<string, any> | null;\n        livemode: boolean;\n        lookup_key: string | null;\n        metadata: Record<string, any>;\n        nickname: string | null;\n        product: string;\n        recurring: {\n          aggregate_usage: string | null;\n          interval: 'day' | 'month' | 'week' | 'year';\n          interval_count: number;\n          meter?: string;\n          trial_period_days: number | null;\n          usage_type: 'licensed' | 'metered';\n        } | null;\n        tax_behavior: 'exclusive' | 'inclusive' | 'unspecified';\n        tiers_mode: 'graduated' | 'volume' | null;\n        transform_quantity: Record<string, any> | null;\n        type: 'one_time' | 'recurring';\n        unit_amount: number | null;\n        unit_amount_decimal: string | null;\n      };\n      proration_behavior: string;\n      proration_date: number;\n      quantity: number | null;\n      subscription: string;\n      subscription_item: string;\n      tax_rates: string[];\n    }>;\n    has_more: boolean;\n    url: string;\n  };\n  latest_invoice: string | null;\n  livemode: boolean;\n  metadata: Record<string, any>;\n  next_pending_invoice_item_invoice: number | null;\n  on_behalf_of: string | null;\n  pause_at: number | null;\n  paused_at: number | null;\n  payment_settings: {\n    payment_method_options: Record<string, any> | null;\n    payment_method_types: string[] | null;\n    save_default_payment_method: 'off' | 'on_subscription' | null;\n  } | null;\n  pending_invoice_item_interval: {\n    interval: 'day' | 'month' | 'week' | 'year';\n    interval_count: number;\n  } | null;\n  pending_setup_intent: string | null;\n  pending_update: {\n    billing_cycle_anchor?: number;\n    expires_at: number;\n    subscription_items?: Array<Record<string, any>>;\n    trial_end?: number;\n  } | null;\n  schedule: string | null;\n  start_date: number;\n  status: StripeSubscriptionStatus;\n  test_clock: string | null;\n  transfer_data: {\n    amount_percent: number | null;\n    destination: string;\n  } | null;\n  trial_end: number | null;\n  trial_settings: {\n    end_behavior: {\n      missing_payment_method: 'cancel' | 'create_invoice' | 'off';\n    };\n  } | null;\n  trial_start: number | null;\n}\n\n/**\n * Stripe invoice object (partial)\n */\nexport interface StripeInvoice {\n  id: string;\n  object: 'invoice';\n  account_country: string;\n  account_name: string;\n  account_tax_ids: string[] | null;\n  amount_due: number;\n  amount_paid: number;\n  amount_remaining: number;\n  application: string | null;\n  application_fee_amount: number | null;\n  attempt_count: number;\n  attempted: boolean;\n  auto_advance: boolean;\n  automatic_tax: {\n    enabled: boolean;\n    status: 'complete' | 'failed' | 'requires_location_inputs' | null;\n  };\n  billing_reason: string;\n  charge: string | null;\n  collection_method: 'charge_automatically' | 'send_invoice';\n  created: number;\n  currency: string;\n  custom_fields: Array<{ name: string; value: string }> | null;\n  customer: string | null;\n  customer_address: Record<string, any> | null;\n  customer_email: string | null;\n  customer_name: string | null;\n  customer_phone: string | null;\n  customer_shipping: Record<string, any> | null;\n  customer_tax_exempt: 'exempt' | 'none' | 'reverse';\n  customer_tax_ids: string[];\n  default_payment_method: string | null;\n  default_source: string | null;\n  default_tax_rates: string[];\n  description: string | null;\n  discount: string | null;\n  discounts: string[];\n  due_date: number | null;\n  effective_at: number | null;\n  email: string | null;\n  ending_balance: number | null;\n  footer: string | null;\n  from_invoice: string | null;\n  hosted_invoice_url: string | null;\n  id: string;\n  invoice_pdf: string | null;\n  last_finalization_error: Record<string, any> | null;\n  latest_revision: string | null;\n  lines: {\n    object: 'list';\n    data: Array<Record<string, any>>;\n    has_more: boolean;\n    url: string;\n  };\n  livemode: boolean;\n  metadata: Record<string, any>;\n  next_payment_attempt: number | null;\n  number: string | null;\n  on_behalf_of: string | null;\n  paid: boolean;\n  paid_out_of_band: boolean;\n  payment_intent: string | null;\n  payment_settings: {\n    custom_fields: Array<{ name: string; value: string }> | null;\n    default_mandate: string | null;\n    footer: string | null;\n    payment_method_options: Record<string, any> | null;\n    payment_method_types: string[] | null;\n  } | null;\n  period_end: number;\n  period_start: number;\n  post_payment_actions: {\n    invoices_to_void: string[];\n    scheduled_cancellations: Array<Record<string, any>>;\n  } | null;\n  previous_payment_intent: string | null;\n  quote: string | null;\n  receipt_number: string | null;\n  rendering: {\n    amount_due_in_words: string;\n    pdf: Record<string, any> | null;\n  } | null;\n  rendering_options: Record<string, any> | null;\n  revision_number: number | null;\n  scheduled_header_settings: Record<string, any> | null;\n  starting_balance: number;\n  statement_descriptor: string | null;\n  status: 'draft' | 'open' | 'paid' | 'uncollectible' | 'void';\n  status_transitions: {\n    finalized_at: number | null;\n    marked_uncollectible_at: number | null;\n    paid_at: number | null;\n    voided_at: number | null;\n  };\n  subscription: string | null;\n  subtotal: number;\n  subtotal_excluding_tax: number | null;\n  tax: number | null;\n  test_clock: string | null;\n  threshold_reason: {\n    amount_gte: number | null;\n    item_reasons: Array<Record<string, any>>;\n  } | null;\n  total: number;\n  total_discount_amounts: Array<{\n    amount: number;\n    discount: string;\n  }>;\n  total_excluding_tax: number | null;\n  total_tax_amounts: Array<Record<string, any>>;\n  transfer_data: {\n    amount: number | null;\n    destination: string;\n  } | null;\n  transfer_data_destination: string | null;\n  transfer_enabled: boolean;\n  url: string | null;\n  verify_with_microseconds: boolean;\n}\n\n/**\n * Stripe charge object (partial)\n */\nexport interface StripeCharge {\n  id: string;\n  object: 'charge';\n  amount: number;\n  amount_captured: number;\n  amount_refunded: number;\n  application: string | null;\n  application_fee: string | null;\n  application_fee_amount: number | null;\n  balance_transaction: string | null;\n  billing_details: Record<string, any> | null;\n  calculated_statement_descriptor: string | null;\n  captured: boolean;\n  created: number;\n  currency: string;\n  customer: string | null;\n  description: string | null;\n  destination: string | null;\n  dispute: string | null;\n  disputed: boolean;\n  failure_balance_transaction: string | null;\n  failure_code: string | null;\n  failure_message: string | null;\n  fraud_details: {\n    stripe_report: 'fraudulent' | 'safe' | null;\n    user_report: 'fraudulent' | 'safe' | null;\n  } | null;\n  invoice: string | null;\n  livemode: boolean;\n  metadata: Record<string, any>;\n  outcome: {\n    network_status: string;\n    reason: string | null;\n    risk_level: 'normal' | 'elevated' | 'highest';\n    risk_score: number;\n    seller_message: string;\n    type: string;\n  };\n  paid: boolean;\n  payment_intent: string | null;\n  payment_method: string | null;\n  payment_method_details: Record<string, any>;\n  receipt_email: string | null;\n  receipt_number: string | null;\n  receipt_url: string | null;\n  refunded: boolean;\n  refunds: {\n    object: 'list';\n    data: Array<Record<string, any>>;\n    has_more: boolean;\n    total_count: number;\n    url: string;\n  };\n  review: string | null;\n  shipping: Record<string, any> | null;\n  source: Record<string, any>;\n  source_transfer: string | null;\n  statement_descriptor: string | null;\n  statement_descriptor_suffix: string | null;\n  status: 'succeeded' | 'failed' | 'pending';\n  transfer_data: {\n    amount: number | null;\n    destination: string;\n  } | null;\n  transfer_group: string | null;\n}\n\n/**\n * Parsed Stripe webhook event\n */\nexport interface ParsedStripeEvent {\n  event_id: string;\n  event_type: StripeWebhookEventType;\n  created_at: number;\n  customer_id: string | null;\n  subscription_id?: string;\n  subscription_status?: StripeSubscriptionStatus;\n  email?: string;\n  currency?: string;\n  amount_cents?: number;\n  plan_id?: string;\n  plan_name?: string;\n  interval?: 'month' | 'year';\n  trial_start?: number;\n  trial_end?: number;\n  current_period_start?: number;\n  current_period_end?: number;\n  canceled_at?: number;\n  ended_at?: number;\n  invoice_id?: string;\n  invoice_status?: string;\n  charge_id?: string;\n  payment_status?: string;\n  error_message?: string;\n  object_type: 'subscription' | 'customer' | 'invoice' | 'charge' | 'payment_intent';\n}\n","/**\n * Stripe Webhook Processor\n * Process Stripe subscription and payment events, store in Growth Data Plane\n * Feature: GDP-007\n *\n * Handles subscription lifecycle events:\n * - customer.subscription.created: New subscription\n * - customer.subscription.updated: Subscription changes\n * - customer.subscription.deleted: Subscription canceled/ended\n * - invoice.payment_succeeded: Payment received\n * - invoice.payment_failed: Payment failed\n */\n\nimport {\n  StripeWebhookEvent,\n  StripeWebhookEventType,\n  StripeSubscription,\n  StripeCustomer,\n  StripeInvoice,\n  StripeCharge,\n  ParsedStripeEvent,\n} from '@/types/stripeWebhook';\nimport {\n  SubscriptionStatus,\n  SubscriptionInterval,\n  EventType as GDPEventType,\n} from '@/types/growthDataPlane';\nimport { createEvent, findOrCreatePerson, createSubscription, updateSubscription, getSubscription } from './growthDataPlane';\nimport { createSnapshotFromSubscription, getLatestSubscriptionSnapshot } from './subscriptionSnapshot';\n\n/**\n * Map Stripe subscription status to our SubscriptionStatus\n */\nfunction mapStripeSubscriptionStatus(status: string): SubscriptionStatus {\n  const mapping: Record<string, SubscriptionStatus> = {\n    trialing: 'trialing',\n    active: 'active',\n    past_due: 'past_due',\n    canceled: 'canceled',\n    unpaid: 'unpaid',\n    incomplete: 'incomplete',\n    incomplete_expired: 'incomplete',\n  };\n  return mapping[status] || ('active' as SubscriptionStatus);\n}\n\n/**\n * Map Stripe interval to our SubscriptionInterval\n */\nfunction mapStripeInterval(interval: string): SubscriptionInterval {\n  return interval === 'year' ? 'year' : 'month';\n}\n\n/**\n * Parse Stripe webhook payload into standardized format\n */\nexport function parseStripeWebhook(payload: StripeWebhookEvent): ParsedStripeEvent | null {\n  const { type, data, id, created } = payload;\n\n  try {\n    const object = data.object;\n\n    // Handle subscription events\n    if (type.startsWith('customer.subscription.')) {\n      const subscription = object as StripeSubscription;\n\n      return {\n        event_id: id,\n        event_type: type as StripeWebhookEventType,\n        created_at: created,\n        customer_id: subscription.customer,\n        subscription_id: subscription.id,\n        subscription_status: mapStripeSubscriptionStatus(subscription.status),\n        currency: subscription.currency,\n        plan_id: subscription.items.data[0]?.price?.product || '',\n        interval: mapStripeInterval(subscription.items.data[0]?.price?.recurring?.interval || 'month'),\n        amount_cents: subscription.items.data[0]?.price?.unit_amount || 0,\n        trial_start: subscription.trial_start ? subscription.trial_start * 1000 : undefined,\n        trial_end: subscription.trial_end ? subscription.trial_end * 1000 : undefined,\n        current_period_start: subscription.current_period_start * 1000,\n        current_period_end: subscription.current_period_end * 1000,\n        canceled_at: subscription.canceled_at ? subscription.canceled_at * 1000 : undefined,\n        ended_at: subscription.ended_at ? subscription.ended_at * 1000 : undefined,\n        object_type: 'subscription',\n      };\n    }\n\n    // Handle customer events\n    if (type.startsWith('customer.')) {\n      const customer = object as StripeCustomer;\n\n      return {\n        event_id: id,\n        event_type: type as StripeWebhookEventType,\n        created_at: created,\n        customer_id: customer.id,\n        email: customer.email || undefined,\n        object_type: 'customer',\n      };\n    }\n\n    // Handle invoice events\n    if (type.startsWith('invoice.')) {\n      const invoice = object as StripeInvoice;\n\n      return {\n        event_id: id,\n        event_type: type as StripeWebhookEventType,\n        created_at: created,\n        customer_id: invoice.customer,\n        invoice_id: invoice.id,\n        invoice_status: invoice.status,\n        currency: invoice.currency,\n        amount_cents: invoice.amount_due,\n        subscription_id: invoice.subscription || undefined,\n        payment_status: invoice.paid ? 'succeeded' : 'pending',\n        object_type: 'invoice',\n      };\n    }\n\n    // Handle charge events\n    if (type.startsWith('charge.')) {\n      const charge = object as StripeCharge;\n\n      return {\n        event_id: id,\n        event_type: type as StripeWebhookEventType,\n        created_at: created,\n        customer_id: charge.customer,\n        charge_id: charge.id,\n        currency: charge.currency,\n        amount_cents: charge.amount,\n        payment_status: charge.status,\n        invoice_id: charge.invoice || undefined,\n        object_type: 'charge',\n      };\n    }\n\n    // Handle payment intent events\n    if (type.startsWith('payment_intent.')) {\n      const paymentIntent = object as any;\n\n      return {\n        event_id: id,\n        event_type: type as StripeWebhookEventType,\n        created_at: created,\n        customer_id: paymentIntent.customer,\n        currency: paymentIntent.currency,\n        amount_cents: paymentIntent.amount,\n        payment_status: paymentIntent.status,\n        object_type: 'payment_intent',\n      };\n    }\n\n    return null;\n  } catch (error) {\n    console.error('Error parsing Stripe webhook:', error);\n    return null;\n  }\n}\n\n/**\n * Map event type to GDP event type\n */\nfunction mapEventType(eventType: StripeWebhookEventType): GDPEventType {\n  if (eventType === StripeWebhookEventType.CUSTOMER_SUBSCRIPTION_CREATED) {\n    return 'monetization';\n  }\n  if (\n    eventType === StripeWebhookEventType.INVOICE_PAYMENT_SUCCEEDED ||\n    eventType === StripeWebhookEventType.CHARGE_SUCCEEDED\n  ) {\n    return 'monetization';\n  }\n  if (\n    eventType === StripeWebhookEventType.INVOICE_PAYMENT_FAILED ||\n    eventType === StripeWebhookEventType.CHARGE_FAILED\n  ) {\n    return 'monetization';\n  }\n  return 'retention';\n}\n\n/**\n * Process Stripe webhook and store events/subscriptions in Growth Data Plane\n *\n * @param payload - Stripe webhook event\n * @returns Event ID if successful, null otherwise\n */\nexport async function processStripeWebhook(\n  payload: StripeWebhookEvent\n): Promise<{ eventId: string | null; subscriptionId?: string }> {\n  try {\n    // Parse webhook\n    const parsed = parseStripeWebhook(payload);\n    if (!parsed) {\n      console.log(`Skipping Stripe event type: ${payload.type}`);\n      return { eventId: null };\n    }\n\n    // Get customer email if available\n    let personEmail: string | undefined;\n    if (parsed.email) {\n      personEmail = parsed.email;\n    }\n\n    // For subscription and invoice events, find person by customer ID\n    let person = null;\n\n    if (parsed.customer_id && personEmail) {\n      person = await findOrCreatePerson({\n        identity_type: 'email',\n        identity_value: personEmail,\n        source: 'stripe',\n        email: personEmail,\n      });\n    } else if (parsed.customer_id) {\n      // Try to find by customer ID\n      person = await findOrCreatePerson({\n        identity_type: 'user_id',\n        identity_value: parsed.customer_id,\n        source: 'stripe',\n      });\n    }\n\n    if (!person) {\n      console.warn(`Could not find or create person for Stripe event: ${parsed.event_type}`);\n      return { eventId: null };\n    }\n\n    // Handle subscription events\n    if (parsed.object_type === 'subscription' && parsed.subscription_id) {\n      if (\n        parsed.event_type === StripeWebhookEventType.CUSTOMER_SUBSCRIPTION_CREATED ||\n        parsed.event_type === StripeWebhookEventType.CUSTOMER_SUBSCRIPTION_UPDATED\n      ) {\n        // Try to update existing subscription, if not found, create new\n        let subscription;\n        try {\n          await updateSubscription(parsed.subscription_id, {\n            status: parsed.subscription_status,\n            amount_cents: parsed.amount_cents || 0,\n            interval: parsed.interval || 'month',\n            current_period_start: new Date(parsed.current_period_start!).toISOString(),\n            current_period_end: new Date(parsed.current_period_end!).toISOString(),\n            canceled_at: parsed.canceled_at ? new Date(parsed.canceled_at).toISOString() : undefined,\n            ended_at: parsed.ended_at ? new Date(parsed.ended_at).toISOString() : undefined,\n          });\n          // Get updated subscription for snapshot\n          subscription = await getSubscription(parsed.subscription_id);\n        } catch {\n          // If update fails, create new subscription\n          if (parsed.event_type === StripeWebhookEventType.CUSTOMER_SUBSCRIPTION_CREATED) {\n            subscription = await createSubscription({\n              person_id: person.id,\n              stripe_subscription_id: parsed.subscription_id,\n              stripe_customer_id: parsed.customer_id!,\n              plan_id: parsed.plan_id || 'unknown',\n              plan_name: parsed.plan_name,\n              status: parsed.subscription_status || 'active',\n              amount_cents: parsed.amount_cents || 0,\n              currency: parsed.currency || 'usd',\n              interval: parsed.interval || 'month',\n              current_period_start: new Date(parsed.current_period_start!).toISOString(),\n              current_period_end: new Date(parsed.current_period_end!).toISOString(),\n              trial_start: parsed.trial_start ? new Date(parsed.trial_start).toISOString() : undefined,\n              trial_end: parsed.trial_end ? new Date(parsed.trial_end).toISOString() : undefined,\n              canceled_at: parsed.canceled_at ? new Date(parsed.canceled_at).toISOString() : undefined,\n            });\n          }\n        }\n\n        // Create subscription snapshot (GDP-008)\n        if (subscription) {\n          try {\n            const previousSnapshot = await getLatestSubscriptionSnapshot(subscription.id);\n            await createSnapshotFromSubscription(subscription, previousSnapshot || undefined);\n          } catch (snapshotError) {\n            console.error('Failed to create subscription snapshot:', snapshotError);\n            // Don't fail the webhook if snapshot creation fails\n          }\n        }\n      } else if (parsed.event_type === StripeWebhookEventType.CUSTOMER_SUBSCRIPTION_DELETED) {\n        // Mark subscription as canceled\n        await updateSubscription(parsed.subscription_id, {\n          status: 'canceled',\n          canceled_at: new Date().toISOString(),\n          ended_at: new Date().toISOString(),\n        });\n\n        // Create snapshot for cancellation (GDP-008)\n        try {\n          const subscription = await getSubscription(parsed.subscription_id);\n          if (subscription) {\n            const previousSnapshot = await getLatestSubscriptionSnapshot(subscription.id);\n            await createSnapshotFromSubscription(subscription, previousSnapshot || undefined);\n          }\n        } catch (snapshotError) {\n          console.error('Failed to create subscription snapshot:', snapshotError);\n        }\n      }\n    }\n\n    // Create event record\n    const event = await createEvent({\n      person_id: person.id,\n      event_name: `stripe.${parsed.event_type}`,\n      event_type: mapEventType(parsed.event_type),\n      event_source: 'stripe',\n      event_id: parsed.event_id,\n      event_time: new Date(parsed.created_at * 1000).toISOString(),\n\n      // Subscription fields\n      subscription_id: parsed.subscription_id,\n      subscription_status: parsed.subscription_status,\n      plan_id: parsed.plan_id,\n      mrr_cents: parsed.amount_cents ? (parsed.interval === 'year' ? Math.round(parsed.amount_cents / 12) : parsed.amount_cents) : 0,\n\n      // Revenue\n      revenue_cents: parsed.amount_cents,\n      currency: parsed.currency || 'usd',\n\n      // Additional properties\n      properties: {\n        invoice_id: parsed.invoice_id,\n        charge_id: parsed.charge_id,\n        customer_id: parsed.customer_id,\n        payment_status: parsed.payment_status,\n        interval: parsed.interval,\n        error_message: parsed.error_message,\n      },\n    });\n\n    console.log(`Stored Stripe event: ${parsed.event_type} for customer ${parsed.customer_id}`);\n\n    return {\n      eventId: event.id,\n      subscriptionId: parsed.subscription_id,\n    };\n  } catch (error) {\n    console.error('Error processing Stripe webhook:', error);\n    return { eventId: null };\n  }\n}\n\n/**\n * Map Stripe webhook event type to a human-readable name\n */\nexport function getEventName(eventType: StripeWebhookEventType): string {\n  const names: Record<StripeWebhookEventType, string> = {\n    [StripeWebhookEventType.CUSTOMER_CREATED]: 'Customer Created',\n    [StripeWebhookEventType.CUSTOMER_UPDATED]: 'Customer Updated',\n    [StripeWebhookEventType.CUSTOMER_DELETED]: 'Customer Deleted',\n    [StripeWebhookEventType.CUSTOMER_SUBSCRIPTION_CREATED]: 'Subscription Created',\n    [StripeWebhookEventType.CUSTOMER_SUBSCRIPTION_UPDATED]: 'Subscription Updated',\n    [StripeWebhookEventType.CUSTOMER_SUBSCRIPTION_DELETED]: 'Subscription Canceled',\n    [StripeWebhookEventType.CUSTOMER_SUBSCRIPTION_TRIAL_WILL_END]: 'Subscription Trial Ending',\n    [StripeWebhookEventType.INVOICE_CREATED]: 'Invoice Created',\n    [StripeWebhookEventType.INVOICE_FINALIZED]: 'Invoice Finalized',\n    [StripeWebhookEventType.INVOICE_PAYMENT_SUCCEEDED]: 'Payment Succeeded',\n    [StripeWebhookEventType.INVOICE_PAYMENT_FAILED]: 'Payment Failed',\n    [StripeWebhookEventType.INVOICE_PAYMENT_ACTION_REQUIRED]: 'Payment Action Required',\n    [StripeWebhookEventType.INVOICE_UPCOMING]: 'Upcoming Invoice',\n    [StripeWebhookEventType.CHARGE_SUCCEEDED]: 'Charge Succeeded',\n    [StripeWebhookEventType.CHARGE_FAILED]: 'Charge Failed',\n    [StripeWebhookEventType.CHARGE_REFUNDED]: 'Charge Refunded',\n    [StripeWebhookEventType.CHARGE_DISPUTE_CREATED]: 'Charge Dispute',\n    [StripeWebhookEventType.PAYMENT_INTENT_SUCCEEDED]: 'Payment Intent Succeeded',\n    [StripeWebhookEventType.PAYMENT_INTENT_PAYMENT_FAILED]: 'Payment Intent Failed',\n  };\n\n  return names[eventType] || eventType;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}