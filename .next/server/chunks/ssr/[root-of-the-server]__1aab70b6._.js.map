{"version":3,"sources":["../../../../node_modules/next/src/server/route-modules/app-page/module.compiled.js","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.ts","../../../../node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts","../../../../src/services/retentionTracking.ts","../../../../src/components/TrackingProvider.tsx"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxRuntime\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n","/**\n * Retention Event Tracking\n *\n * Tracks user retention and feature discovery events:\n * - return_visit: When users return to the platform\n * - feature_discovery: When users discover/use features for the first time\n */\n\nimport { tracking } from './tracking';\n\nconst STORAGE_KEY_PREFIX = 'retention_tracking_';\nconst LAST_VISIT_KEY = `${STORAGE_KEY_PREFIX}last_visit`;\nconst DISCOVERED_FEATURES_KEY = `${STORAGE_KEY_PREFIX}discovered_features`;\nconst VISIT_COUNT_KEY = `${STORAGE_KEY_PREFIX}visit_count`;\nconst FIRST_VISIT_KEY = `${STORAGE_KEY_PREFIX}first_visit`;\n\n// Return visit threshold: 30 minutes (if they come back after 30 min, it's a new visit)\nconst RETURN_VISIT_THRESHOLD_MS = 30 * 60 * 1000; // 30 minutes\n\nexport type DiscoverableFeature =\n  | 'ad_editor'\n  | 'template_library'\n  | 'brand_kit'\n  | 'batch_render'\n  | 'campaign_generator'\n  | 'csv_import'\n  | 'screenshot_editor'\n  | 'device_frames'\n  | 'caption_overlay'\n  | 'screenshot_resize'\n  | 'locale_export'\n  | 'asset_library'\n  | 'custom_product_page'\n  | 'ppo_test'\n  | 'app_preview_generator'\n  | 'analytics_dashboard'\n  | 'voice_clone'\n  | 'text_to_video'\n  | 'image_generation'\n  | 'approval_workflow'\n  | 'ai_variants'\n  | 'localization'\n  | 'creative_qa';\n\ninterface RetentionData {\n  visitCount: number;\n  firstVisit: string;\n  lastVisit: string;\n  discoveredFeatures: DiscoverableFeature[];\n}\n\n/**\n * Check if browser environment (not SSR)\n */\nfunction isBrowser(): boolean {\n  return typeof window !== 'undefined' && typeof localStorage !== 'undefined';\n}\n\n/**\n * Get data from localStorage\n */\nfunction getLocalStorageItem(key: string): string | null {\n  if (!isBrowser()) return null;\n  try {\n    return localStorage.getItem(key);\n  } catch (error) {\n    console.error('Failed to read from localStorage:', error);\n    return null;\n  }\n}\n\n/**\n * Set data in localStorage\n */\nfunction setLocalStorageItem(key: string, value: string): void {\n  if (!isBrowser()) return;\n  try {\n    localStorage.setItem(key, value);\n  } catch (error) {\n    console.error('Failed to write to localStorage:', error);\n  }\n}\n\n/**\n * Get all retention data\n */\nfunction getRetentionData(): RetentionData {\n  const visitCount = parseInt(getLocalStorageItem(VISIT_COUNT_KEY) || '0', 10);\n  const firstVisit = getLocalStorageItem(FIRST_VISIT_KEY) || new Date().toISOString();\n  const lastVisit = getLocalStorageItem(LAST_VISIT_KEY) || '';\n  const discoveredFeaturesRaw = getLocalStorageItem(DISCOVERED_FEATURES_KEY) || '[]';\n\n  let discoveredFeatures: DiscoverableFeature[] = [];\n  try {\n    discoveredFeatures = JSON.parse(discoveredFeaturesRaw);\n  } catch (error) {\n    console.error('Failed to parse discovered features:', error);\n    discoveredFeatures = [];\n  }\n\n  return {\n    visitCount,\n    firstVisit,\n    lastVisit,\n    discoveredFeatures,\n  };\n}\n\n/**\n * Calculate days since first visit\n */\nfunction getDaysSinceFirstVisit(firstVisit: string): number {\n  if (!firstVisit) return 0;\n  const firstVisitDate = new Date(firstVisit);\n  const now = new Date();\n  const diffMs = now.getTime() - firstVisitDate.getTime();\n  return Math.floor(diffMs / (1000 * 60 * 60 * 24));\n}\n\n/**\n * Calculate hours since last visit\n */\nfunction getHoursSinceLastVisit(lastVisit: string): number | null {\n  if (!lastVisit) return null;\n  const lastVisitDate = new Date(lastVisit);\n  const now = new Date();\n  const diffMs = now.getTime() - lastVisitDate.getTime();\n  return Math.floor(diffMs / (1000 * 60 * 60));\n}\n\n/**\n * Track return visit\n * Call this when the user loads the app\n */\nexport function trackReturnVisit(): void {\n  if (!isBrowser()) return;\n\n  const now = new Date();\n  const nowISO = now.toISOString();\n\n  const data = getRetentionData();\n  const lastVisitDate = data.lastVisit ? new Date(data.lastVisit) : null;\n\n  // Calculate if this is a new visit (based on threshold)\n  const isNewVisit = !lastVisitDate ||\n    (now.getTime() - lastVisitDate.getTime()) > RETURN_VISIT_THRESHOLD_MS;\n\n  // If first visit, just record it\n  if (data.visitCount === 0) {\n    setLocalStorageItem(FIRST_VISIT_KEY, nowISO);\n    setLocalStorageItem(LAST_VISIT_KEY, nowISO);\n    setLocalStorageItem(VISIT_COUNT_KEY, '1');\n\n    // Don't track return_visit on first visit\n    return;\n  }\n\n  // If new visit (after threshold), track it\n  if (isNewVisit) {\n    const newVisitCount = data.visitCount + 1;\n    const daysSinceFirstVisit = getDaysSinceFirstVisit(data.firstVisit);\n    const hoursSinceLastVisit = getHoursSinceLastVisit(data.lastVisit);\n\n    // Track the return visit event\n    tracking.track('return_visit', {\n      visitCount: newVisitCount,\n      daysSinceFirstVisit,\n      hoursSinceLastVisit,\n      firstVisit: data.firstVisit,\n      lastVisit: data.lastVisit,\n      timestamp: nowISO,\n    });\n\n    // Update storage\n    setLocalStorageItem(LAST_VISIT_KEY, nowISO);\n    setLocalStorageItem(VISIT_COUNT_KEY, newVisitCount.toString());\n  }\n\n  // Always update last visit timestamp (even if not a \"new visit\")\n  setLocalStorageItem(LAST_VISIT_KEY, nowISO);\n}\n\n/**\n * Track feature discovery\n * Call this when a user uses a feature for the first time\n */\nexport function trackFeatureDiscovery(feature: DiscoverableFeature): void {\n  if (!isBrowser()) return;\n\n  const data = getRetentionData();\n\n  // Check if already discovered\n  if (data.discoveredFeatures.includes(feature)) {\n    return; // Already tracked\n  }\n\n  // Add to discovered features\n  const updatedFeatures = [...data.discoveredFeatures, feature];\n  setLocalStorageItem(DISCOVERED_FEATURES_KEY, JSON.stringify(updatedFeatures));\n\n  const daysSinceFirstVisit = getDaysSinceFirstVisit(data.firstVisit);\n  const totalDiscoveredCount = updatedFeatures.length;\n\n  // Track the feature discovery event\n  tracking.track('feature_discovery', {\n    feature,\n    totalDiscoveredCount,\n    visitCount: data.visitCount,\n    daysSinceFirstVisit,\n    timestamp: new Date().toISOString(),\n  });\n}\n\n/**\n * Check if a feature has been discovered\n */\nexport function hasDiscoveredFeature(feature: DiscoverableFeature): boolean {\n  if (!isBrowser()) return false;\n  const data = getRetentionData();\n  return data.discoveredFeatures.includes(feature);\n}\n\n/**\n * Get retention statistics\n */\nexport function getRetentionStats(): RetentionData & {\n  daysSinceFirstVisit: number;\n  hoursSinceLastVisit: number | null;\n} {\n  const data = getRetentionData();\n  return {\n    ...data,\n    daysSinceFirstVisit: getDaysSinceFirstVisit(data.firstVisit),\n    hoursSinceLastVisit: getHoursSinceLastVisit(data.lastVisit),\n  };\n}\n\n/**\n * Reset retention tracking (for testing)\n */\nexport function resetRetentionTracking(): void {\n  if (!isBrowser()) return;\n  try {\n    localStorage.removeItem(LAST_VISIT_KEY);\n    localStorage.removeItem(DISCOVERED_FEATURES_KEY);\n    localStorage.removeItem(VISIT_COUNT_KEY);\n    localStorage.removeItem(FIRST_VISIT_KEY);\n  } catch (error) {\n    console.error('Failed to reset retention tracking:', error);\n  }\n}\n","'use client';\n\nimport { useEffect, createContext, useContext, ReactNode } from 'react';\nimport { tracking } from '../services/tracking';\nimport { ITrackingService } from '../types/tracking';\nimport { trackReturnVisit } from '../services/retentionTracking';\n\nconst TrackingContext = createContext<ITrackingService>(tracking);\n\nexport const useTracking = () => {\n  return useContext(TrackingContext);\n};\n\ninterface TrackingProviderProps {\n  children: ReactNode;\n  apiKey?: string;\n  host?: string;\n  enabled?: boolean;\n}\n\nexport function TrackingProvider({\n  children,\n  apiKey,\n  host,\n  enabled = true,\n}: TrackingProviderProps) {\n  useEffect(() => {\n    const key = apiKey || process.env.NEXT_PUBLIC_POSTHOG_KEY;\n    const hostUrl = host || process.env.NEXT_PUBLIC_POSTHOG_HOST;\n\n    if (key) {\n      tracking.initialize({\n        apiKey: key,\n        host: hostUrl,\n        enabled,\n      });\n    }\n\n    // Track return visit after a short delay (to ensure tracking is initialized)\n    const timer = setTimeout(() => {\n      trackReturnVisit();\n    }, 500);\n\n    return () => clearTimeout(timer);\n  }, [apiKey, host, enabled]);\n\n  return (\n    <TrackingContext.Provider value={tracking}>\n      {children}\n    </TrackingContext.Provider>\n  );\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK","vendored","ReactJsxRuntime","React"],"mappings":"2NA0BQG,GAAOC,OAAO,CAAGC,EAAQ,CAAA,CAAA,IAAA,mCC1BjCF,EAAOC,OAAO,CACZC,EAAQ,CAAA,CAAA,IAAA,IACRI,QAAQ,CAAC,YAAY,CAAEC,eAAe,gCCFxCP,EAAOC,OAAO,CACZC,EAAQ,CAAA,CAAA,IAAA,IACRI,QAAQ,CAAC,YAAY,CAAEE,KAAK,0BCM9B,EAAA,CAAA,CAAA,QA8HO,SAAS,IA8ChB,CAMO,SAAS,EAAsB,CAA4B,EAyBlE,0GCjNA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAEA,EAAA,EAAA,CAAA,CAAA,QAEA,IAAM,EAAkB,CAAA,EAAA,EAAA,aAAA,AAAa,EAAmB,EAAA,QAAQ,EAazD,SAAS,EAAiB,UAC/B,CAAQ,QACR,CAAM,MACN,CAAI,CACJ,WAAU,CAAI,CACQ,EAqBtB,MApBA,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,KACR,IAAM,EAAM,GAAU,QAAQ,GAAG,CAAC,uBAAuB,CACnD,EAAU,GAAQ,QAAQ,GAAG,CAAC,wBAAwB,AAExD,IACF,CADO,CACP,QAAQ,CAAC,UAAU,CAAC,CAClB,OAAQ,EACR,KAAM,UACN,CACF,GAIF,IAAM,EAAQ,WAAW,KACvB,CAAA,EAAA,EAAA,gBAAA,AAAgB,GAClB,EAAG,KAEH,MAAO,IAAM,aAAa,EAC5B,EAAG,CAAC,EAAQ,EAAM,EAAQ,EAGxB,CAAA,EAAA,EAAA,GAAA,EAAC,EAAgB,QAAQ,CAAA,CAAC,MAAO,EAAA,QAAQ,UACtC,GAGP,+CA1C2B,IAClB,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC","ignoreList":[0,1,2]}