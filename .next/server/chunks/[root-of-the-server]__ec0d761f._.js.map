{"version":3,"sources":["../../../src/services/supabase.ts","../../../src/services/growthDataPlane.ts"],"sourcesContent":["/**\n * Supabase Client Service\n * GDP-001: Supabase Schema Setup\n *\n * This service provides a configured Supabase client for the Growth Data Plane.\n */\n\nimport { createClient } from '@supabase/supabase-js';\n\n// Supabase configuration from environment variables\nconst supabaseUrl = process.env.SUPABASE_URL || '';\nconst supabaseAnonKey = process.env.SUPABASE_ANON_KEY || '';\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY || '';\n\nif (!supabaseUrl) {\n  console.warn('SUPABASE_URL not configured');\n}\n\nif (!supabaseAnonKey && !supabaseServiceKey) {\n  console.warn('SUPABASE_ANON_KEY or SUPABASE_SERVICE_KEY not configured');\n}\n\n/**\n * Client-side Supabase client (uses anon key)\n * Use this in browser environments\n */\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey, {\n  auth: {\n    persistSession: false,\n  },\n});\n\n/**\n * Server-side Supabase client (uses service key)\n * Use this in API routes and server-side code\n * Has elevated permissions to bypass RLS\n */\nexport const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {\n  auth: {\n    persistSession: false,\n    autoRefreshToken: false,\n  },\n});\n\n/**\n * Check if Supabase is configured\n */\nexport function isSupabaseConfigured(): boolean {\n  return !!(supabaseUrl && (supabaseAnonKey || supabaseServiceKey));\n}\n\nexport default supabase;\n","/**\n * Growth Data Plane Service\n * GDP-001: Supabase Schema Setup\n *\n * This service provides methods to interact with the Growth Data Plane schema:\n * - Person management (find, create, update, merge)\n * - Event tracking (create, query)\n * - Subscription management (create, update)\n * - Identity stitching\n */\n\nimport { supabaseAdmin } from './supabase';\nimport {\n  Person,\n  IdentityLink,\n  Event,\n  Subscription,\n  CreatePersonInput,\n  CreateEventInput,\n  CreateSubscriptionInput,\n  FindOrCreatePersonParams,\n  IdentityType,\n} from '../types/growthDataPlane';\n\n/**\n * Person Management\n */\n\nexport async function findPersonByIdentity(\n  identityType: IdentityType,\n  identityValue: string\n): Promise<Person | null> {\n  const { data: link, error: linkError } = await supabaseAdmin\n    .from('identity_link')\n    .select('person_id')\n    .eq('identity_type', identityType)\n    .eq('identity_value', identityValue)\n    .single();\n\n  if (linkError || !link) {\n    return null;\n  }\n\n  const { data: person, error: personError } = await supabaseAdmin\n    .from('person')\n    .select('*')\n    .eq('id', link.person_id)\n    .single();\n\n  if (personError) {\n    throw new Error(`Error fetching person: ${personError.message}`);\n  }\n\n  return person;\n}\n\nexport async function findOrCreatePerson(\n  params: FindOrCreatePersonParams\n): Promise<Person> {\n  // Use the database function for atomic find-or-create\n  const { data, error } = await supabaseAdmin.rpc('find_or_create_person', {\n    p_identity_type: params.identity_type,\n    p_identity_value: params.identity_value,\n    p_source: params.source || null,\n    p_email: params.email || null,\n    p_user_id: params.user_id || null,\n    p_first_name: params.first_name || null,\n    p_last_name: params.last_name || null,\n  });\n\n  if (error) {\n    throw new Error(`Error in find_or_create_person: ${error.message}`);\n  }\n\n  // Fetch and return the person record\n  const { data: person, error: personError } = await supabaseAdmin\n    .from('person')\n    .select('*')\n    .eq('id', data)\n    .single();\n\n  if (personError) {\n    throw new Error(`Error fetching person: ${personError.message}`);\n  }\n\n  return person;\n}\n\nexport async function createPerson(input: CreatePersonInput): Promise<Person> {\n  const { data, error } = await supabaseAdmin\n    .from('person')\n    .insert(input)\n    .select()\n    .single();\n\n  if (error) {\n    throw new Error(`Error creating person: ${error.message}`);\n  }\n\n  return data;\n}\n\nexport async function updatePerson(\n  personId: string,\n  updates: Partial<CreatePersonInput>\n): Promise<Person> {\n  const { data, error } = await supabaseAdmin\n    .from('person')\n    .update(updates)\n    .eq('id', personId)\n    .select()\n    .single();\n\n  if (error) {\n    throw new Error(`Error updating person: ${error.message}`);\n  }\n\n  return data;\n}\n\nexport async function mergePersonRecords(\n  sourcePersonId: string,\n  targetPersonId: string\n): Promise<boolean> {\n  const { data, error } = await supabaseAdmin.rpc('merge_person_records', {\n    p_source_person_id: sourcePersonId,\n    p_target_person_id: targetPersonId,\n  });\n\n  if (error) {\n    throw new Error(`Error merging person records: ${error.message}`);\n  }\n\n  return data;\n}\n\n/**\n * Event Tracking\n */\n\nexport async function createEvent(input: CreateEventInput): Promise<Event> {\n  const { data, error } = await supabaseAdmin\n    .from('event')\n    .insert(input)\n    .select()\n    .single();\n\n  if (error) {\n    // Check for duplicate event_id (deduplication)\n    if (error.code === '23505') {\n      console.log(`Event deduplicated: ${input.event_id} from ${input.event_source}`);\n      // Fetch existing event\n      const { data: existing } = await supabaseAdmin\n        .from('event')\n        .select('*')\n        .eq('event_id', input.event_id)\n        .eq('event_source', input.event_source)\n        .single();\n      return existing!;\n    }\n    throw new Error(`Error creating event: ${error.message}`);\n  }\n\n  return data;\n}\n\nexport async function getPersonEvents(\n  personId: string,\n  limit = 100\n): Promise<Event[]> {\n  const { data, error } = await supabaseAdmin\n    .from('event')\n    .select('*')\n    .eq('person_id', personId)\n    .order('event_time', { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    throw new Error(`Error fetching person events: ${error.message}`);\n  }\n\n  return data;\n}\n\nexport async function getEventsByName(\n  eventName: string,\n  limit = 100\n): Promise<Event[]> {\n  const { data, error } = await supabaseAdmin\n    .from('event')\n    .select('*')\n    .eq('event_name', eventName)\n    .order('event_time', { ascending: false })\n    .limit(limit);\n\n  if (error) {\n    throw new Error(`Error fetching events: ${error.message}`);\n  }\n\n  return data;\n}\n\n/**\n * Subscription Management\n */\n\nexport async function createSubscription(\n  input: CreateSubscriptionInput\n): Promise<Subscription> {\n  const { data, error } = await supabaseAdmin\n    .from('subscription')\n    .insert(input)\n    .select()\n    .single();\n\n  if (error) {\n    throw new Error(`Error creating subscription: ${error.message}`);\n  }\n\n  return data;\n}\n\nexport async function updateSubscription(\n  stripeSubscriptionId: string,\n  updates: Partial<CreateSubscriptionInput>\n): Promise<Subscription> {\n  const { data, error } = await supabaseAdmin\n    .from('subscription')\n    .update(updates)\n    .eq('stripe_subscription_id', stripeSubscriptionId)\n    .select()\n    .single();\n\n  if (error) {\n    throw new Error(`Error updating subscription: ${error.message}`);\n  }\n\n  return data;\n}\n\nexport async function getSubscription(\n  subscriptionId: string\n): Promise<Subscription | null> {\n  const { data, error } = await supabaseAdmin\n    .from('subscription')\n    .select('*')\n    .eq('id', subscriptionId)\n    .single();\n\n  if (error && error.code === 'PGRST116') {\n    // No rows found\n    return null;\n  }\n\n  if (error) {\n    throw new Error(`Error fetching subscription: ${error.message}`);\n  }\n\n  return data;\n}\n\nexport async function getPersonSubscriptions(\n  personId: string\n): Promise<Subscription[]> {\n  const { data, error } = await supabaseAdmin\n    .from('subscription')\n    .select('*')\n    .eq('person_id', personId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    throw new Error(`Error fetching person subscriptions: ${error.message}`);\n  }\n\n  return data;\n}\n\n/**\n * Identity Management\n */\n\nexport async function addIdentityLink(\n  personId: string,\n  identityType: IdentityType,\n  identityValue: string,\n  source?: string\n): Promise<IdentityLink> {\n  const { data, error } = await supabaseAdmin\n    .from('identity_link')\n    .insert({\n      person_id: personId,\n      identity_type: identityType,\n      identity_value: identityValue,\n      source,\n    })\n    .select()\n    .single();\n\n  if (error) {\n    // If identity already exists, update last_seen_at\n    if (error.code === '23505') {\n      const { data: existing, error: updateError } = await supabaseAdmin\n        .from('identity_link')\n        .update({ last_seen_at: new Date().toISOString() })\n        .eq('identity_type', identityType)\n        .eq('identity_value', identityValue)\n        .select()\n        .single();\n\n      if (updateError) {\n        throw new Error(`Error updating identity link: ${updateError.message}`);\n      }\n\n      return existing;\n    }\n    throw new Error(`Error creating identity link: ${error.message}`);\n  }\n\n  return data;\n}\n\nexport async function getPersonIdentities(\n  personId: string\n): Promise<IdentityLink[]> {\n  const { data, error } = await supabaseAdmin\n    .from('identity_link')\n    .select('*')\n    .eq('person_id', personId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    throw new Error(`Error fetching person identities: ${error.message}`);\n  }\n\n  return data;\n}\n\n/**\n * Person Features Computation\n */\n\nexport async function updatePersonFeatures(personId: string): Promise<void> {\n  const { error } = await supabaseAdmin.rpc('update_person_features', {\n    p_person_id: personId,\n  });\n\n  if (error) {\n    throw new Error(`Error updating person features: ${error.message}`);\n  }\n}\n\n/**\n * Analytics / Queries\n */\n\nexport async function getActivePeople(daysBack = 30): Promise<Person[]> {\n  const cutoffDate = new Date();\n  cutoffDate.setDate(cutoffDate.getDate() - daysBack);\n\n  const { data, error } = await supabaseAdmin\n    .from('person')\n    .select('*')\n    .gte('last_seen_at', cutoffDate.toISOString())\n    .order('last_seen_at', { ascending: false });\n\n  if (error) {\n    throw new Error(`Error fetching active people: ${error.message}`);\n  }\n\n  return data;\n}\n\nexport async function getRevenueByPerson(personId: string): Promise<number> {\n  const { data, error } = await supabaseAdmin\n    .from('event')\n    .select('revenue_cents')\n    .eq('person_id', personId)\n    .not('revenue_cents', 'is', null);\n\n  if (error) {\n    throw new Error(`Error fetching revenue: ${error.message}`);\n  }\n\n  const totalRevenue = data.reduce((sum, event) => sum + (event.revenue_cents || 0), 0);\n  return totalRevenue;\n}\n"],"names":[],"mappings":"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"}